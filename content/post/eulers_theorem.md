+++
title = "On Euler's Theorem"
date = "2018-07-15T15:21:35-04:00"

+++

Euler's theorem is named after the great Swiss mathematician [Leonhard Euler] from a paper he published in 1763 containing several proofs of Fermat's little theorem.   Euler's theorem is an attempt to find the smallest possible exponent for which Fermat's little theorem is always true.

First, let's take a look at Fermat's little theorem.

> **[Fermat's little theorem]**
>
>	If `p` is a prime number, then for any integer `a`, the number <code>a<sup>p</sup></code> - a is an integer multiple of `p`.\*
>
> <pre class="math">
> a<sup>p</sup> ≡ a mod p
>
> For example:
>	a = 2
>	p = 7
>
>	2<sup>7</sup> = 128
>	128 - 2 = 126 = 7 * 18
>
> If `a` is not divisible by `p`, Fermat's little theorem is equivalent
> to the statement that `a<sup>(p−1)</sup> − 1` is an integer multiple of `p`.
>
> a<sup>(p - 1)</sup> ≡ 1 mod p
>
> For example:
>	a = 2
>	p = 7
>
>	2<sup>(7-1)</sup> - 1
>	2<sup>6</sup> - 1
>	64 - 1
>	63 = 7 * 9
> </pre>

Next, let's take a look at Euler's theorem.

> **[Euler's theorem]**
>
>	a<sup>ϕ(n)</sup> ≡ 1 mod n
>
>	- It crucially connects two principles, the phi function and [modular exponentiation].
>	- `a` and `n` **must** be coprime!
>	- ϕ(n) is, of course, [Euler's totient function], also known as Euler's phi function.
>	- When `n` is prime, this is the same statement as Fermat's little theorem (specifically, when `a` is not divisible by `p`)!
>	- When `n` is not prime, it is used in public key cryptography algorithms like in [the RSA cryptosystem]!
>
>	Euler's theorem is a generalization of Fermat's little theorem.

Let's see some examples of substituting some values that are coprime into the statement.  To make calculating the phi function simple, we'll use prime numbers for `n`.

<pre class="math">
a = 3
n = 17

a<sup>ϕ(n)</sup> ≡ 1 mod n
3<sup>ϕ(17)</sup> ≡ 1 mod 17
3<sup>16</sup> ≡ 1 mod 17
43046721 ≡ 1 mod 17
1 ≡ 1 mod 17

---

a = 13
n = 307

a<sup>ϕ(n)</sup> ≡ 1 mod n
13<sup>ϕ(307)</sup> ≡ 1 mod 307
3<sup>306</sup> ≡ 1 mod 17
# The number is too big to print, we'll use `bc`:
~:$ bc <<< 13^306%307
1
</pre>

## Euler's Theorem in Action

So, what's the point of this?  Well, Euler's theorem can be used to easily reduce modular exponentiation with large exponents (and to exponents smaller than `n` if `n` is prime)!

For example:

13<sup>5921</sup> mod 19

1. Substitute ϕ(n) for the large exponent.  Recall that `a` and `n` must be coprime!

	<pre class="math">
	13<sup>ϕ(19)</sup> ≡ 1 mod 19
	13<sup>18</sup> ≡ 1 mod 19
	</pre>

2. Use ϕ(19) to reduce the large exponent 5921 into its component parts.

	<pre class="math">
	5921 = 18(328) + 17
	Divisor   = 18
	Quotient  = 328
	Remainder = 17
	</pre>

3. Use the component parts to rewrite the statement.

	<pre class="math">
	# Recall that n<sup>(a*b)</sup> = n<sup>a<sup>b</sup></sup>.
	13<sup>(18*328+17)</sup> mod 19 = 13<sup>18<sup>328</sup></sup> * 13<sup>17</sup> mod 19
	</pre>

4. Calculate!

	<pre class="math">
	13<sup>18<sup>328</sup></sup> * 13<sup>17</sup> mod 19

	# Recall Euler's theorem, i.e., a<sup>ϕ(n)</sup> ≡ 1 mod n:
	13<sup>ϕ(19)</sup> ≡ 1 mod 19
	13<sup>18</sup> ≡ 1 mod 19

	# So, we can simply replace 13<sup>18</sup> with 1!
	13<sup>18<sup>328</sup></sup> mod 19 = 1<sup>328</sup> mod 19
	13<sup>18<sup>328</sup></sup> ≡ 1<sup>328</sup> mod 19
	1<sup>328</sup> * 13<sup>17</sup> mod 19

	# And since 1<sup>k</sup>=1, the large exponent 328 can then
	# be reduced to 1.
	1 * 13<sup>17</sup> mod 19
	13<sup>17</sup> mod 19
	3
	</pre>

Of course, this can be easily verified using `bc`:

	bc <<< 13^5921%19

## Euler's Theorem and Public Key Cryptography

Neat!  And this theorem has even more practical applications, as mentioned earlier, particularly with RSA in the field of cryptography.

As is now known, Euler's theorem ties together ϕ(n) (the phi function) and modular exponentiation.

1. The keys generated by RSA depend on the phi function, the result of which can only be deduced by the prime factorization of the modulus `n`, which is computationally infeasible given a large enough composite number.

2. Further, the choice of the public key `e` can only be reproduced knowing the prime numbers, which again is tied directly to ϕ(n).

	- `e` must be coprime to ϕ(n)
	- `e` must be between 1 and ϕ(n), i.e., `1 < e ϕ(n)`

3. Lastly, the private key `d` can only be reproduced knowing the public key `e` and calculating its [modular multiplicative inverse], again infeasible without knowing the initial prime numbers on which ϕ(n) depends!

	- d*e = 1 mod ϕ(n)

> I've done a post on [the RSA algorithm] which explains this last section in greater depth.

\* Definitions and examples taken from [the Wikipedia article] on Fermat's little theorem.

[Leonhard Euler]: https://en.wikipedia.org/wiki/Leonhard_Euler
[Fermat's little theorem]: https://en.wikipedia.org/wiki/Fermat%27s_little_theorem
[the RSA algorithm]: /2018/07/09/on-rsa/
[Euler's theorem]: https://en.wikipedia.org/wiki/Euler%27s_theorem
[modular exponentiation]: https://en.wikipedia.org/wiki/Modular_exponentiation
[Euler's totient function]: https://en.wikipedia.org/wiki/Euler_totient_function
[the RSA cryptosystem]: https://en.wikipedia.org/wiki/RSA_(cryptosystem)
[modular multiplicative inverse]: https://en.wikipedia.org/wiki/Modular_multiplicative_inverse
[the Wikipedia article]: https://en.wikipedia.org/wiki/Fermat%27s_little_theorem

